<html>
<head>
<meta charset="utf-8">
<title>Road Rash 64 Viewer</title>
<link href='https://fonts.googleapis.com/css?family=Open+Sans:400,400italic,700,700italic' rel='stylesheet' type='text/css'>
<style>
label
{
    user-select: none;
}

body, input, button, label, select
{
    font-family: "Open Sans";
}

select
{
    padding: 1px 6px;
}

body, html {
    height: 100%;
    background: #222;
    color: #FFF;
    margin: 0px;
}
</style>
<script src="js/three.js"></script>
<script src="js/rr64.js"></script>
<script src="js/rr64-model.js"></script>
<script src="js/texture.js"></script>
<script src="js/util.js"></script>
</head>
<body>
<div id="info" style="text-align: center; width: 100%; height: 100%; display: flex; flex-direction: column;">
    <div style="flex: 1;"></div>
    <div id="info-text" style="display: inline-block; padding: 10px; text-align: left; margin: auto; flex: 1; flex-grow: 0;">
        <div style="padding: 10px; font-size: 24px;">Road Rash 64 Map Viewer</div>
        <div style="padding: 10px;">Drag and drop a Road Rash 64 (U).z64 ROM onto<br>this page or click the choose file button below.</div>
        <div style="padding: 10px;"><input type="file" id="file"></div>
        <div style="padding: 10px;">
            Controls:
            <ul>
                <li>WASD - Move camera</li>
                <li>XZ - Move camera up/down</li>
                <li>L-Mouse - Pan camera</li>
                <li>R-Mouse - Rotate camera</li>
                <li>Mouse wheel - Adjust camera speed</li>
            </ul>
        </div>
    </div>
    <div style="flex:1;"></div>
</div>
<div id="container"></div>
<script>

"use strict";

var viewer = null;

function Viewer(queryDomContainer)
{
    var _this = this;
    this.scene = new THREE.Scene();
    this.renderer = new THREE.WebGLRenderer({antialias: false});

    this.layers = {};

    this.hud = new ViewerHUD();

    this.dom = {};
    this.dom['render'] = this.renderer.domElement;
    this.dom['render'].style.imageRendering = "pixelated";
    this.dom['render'].tabIndex = '0';

    this.dom['container'] = document.querySelector(queryDomContainer);
    this.dom['container'].appendChild(this.hud.domElement);
    this.dom['container'].appendChild(this.renderer.domElement);

    this.keysDown = {};

    this.cameraSpeed = 30;
    this.camStepX = 0;
    this.camStepY = 0;
    this.camStepZ = 0;
    this.camRotStepX = 0;
    this.camRotStepY = 0;
    this.cameraNear = 1;
    this.cameraFar = 65535;

    this.fogNear = 1;
    this.fogFar = 5000;

    const clearColor = 0x7B8CCE;
    const cameraDefaultPos = new THREE.Vector3(0, 4000, 0);

    this.width = window.innerWidth;
    this.height = window.innerHeight;

    this.renderer.setPixelRatio(window.devicePixelRatio);
    this.renderer.setSize(this.width, this.height);
    this.renderer.setViewport(0, 0, this.width, this.height);
    this.renderer.setScissorTest(true);
    this.renderer.setScissor(0, 0, this.width, this.height);
    this.renderer.setClearColor(clearColor, 1.0);
    this.renderer.alpha = true;

    this.scene.fog = new THREE.Fog(clearColor, this.cameraFar, this.cameraFar);

    this.camera = new THREE.PerspectiveCamera(60, this.width/this.height, this.cameraNear, this.cameraFar);
    this.camera.rotation.order = "YXZ";

    this.camera.translateX(cameraDefaultPos.x);
    this.camera.translateY(cameraDefaultPos.y);
    this.camera.translateZ(cameraDefaultPos.z);

    this.dom['render'].onkeydown = function(e)
    {
        if(!_this.keyEvents[e.keyCode])
        {
            return;
        }

        _this.keysDown[e.keyCode] = true;
    	e.preventDefault();
    	return false;
    }

    this.dom['render'].onkeyup = function(e)
    {
    	delete _this.keysDown[e.keyCode];
    	e.preventDefault();
    	return false;
    }

    this.dom['render'].oncontextmenu = function(e)
    {
        e.preventDefault();
        return false;
    }

    this.dom['render'].onmousedown = function(e)
    {
        this.requestPointerLock();
        this.focus();
        e.preventDefault();
        return false;
    }

    this.dom['render'].onmouseup = function(e)
    {
        document.exitPointerLock();
    }

    this.dom['render'].onmousemove = function(e)
    {
        if(e.buttons == 0)
        {
            return;
        }

        var movementX = e.movementX / 4;
        var movementY = e.movementY / 4;

        if(e.buttons == 1)
        {
            viewer.camera.translateX(-movementX * 5);
            viewer.camera.translateY(movementY * 5);
        }

        if(e.buttons == 4)
        {
            viewer.camera.translateZ(-movementX * 5);
            viewer.camera.translateZ(movementY * 5);
        }

        if(e.buttons == 2)
        {
            viewer.camera.rotateY(-movementX * 0.01);
            viewer.camera.rotateX(-movementY * 0.01);
            viewer.camera.rotation.z = 0;
        }
    }

    this.dom['render'].onwheel = function(e)
    {
        var d = -(e.deltaY / 100);
        _this.cameraSpeed += d * 5;

        if(_this.cameraSpeed < 10)
        {
            _this.cameraSpeed = 10;
        }
    }

    window.addEventListener('resize', function(e)
    {
        if(!_this.camera || !_this.renderer)
        {
            return;
        }

        _this.width = window.innerWidth;
        _this.height = window.innerHeight;
        _this.camera.aspect = (_this.width / _this.height);
        _this.camera.updateProjectionMatrix();
        _this.renderer.setSize(_this.width, _this.height);
        _this.renderer.setViewport(0, 0, _this.width, _this.height);
        _this.renderer.setScissor(0, 0, _this.width, _this.height);
    });

    this.keyEvents = {
	    //27: function(){ _this.resetCamera() }, // esc - reset camera position
	    87: function(viewer){ viewer.camStepZ = -viewer.cameraSpeed; }, // w - move forward
	    65: function(viewer){ viewer.camStepX = -viewer.cameraSpeed; }, // a - pan left
	    83: function(viewer){ viewer.camStepZ = viewer.cameraSpeed; }, // s - move backward
	    68: function(viewer){ viewer.camStepX = viewer.cameraSpeed; }, // d - pan right
	    90: function(viewer){ viewer.camStepY = -viewer.cameraSpeed; }, // z - move down
	    88: function(viewer){ viewer.camStepY = viewer.cameraSpeed; }, // x - move up
	    40: function(viewer){ viewer.camRotStepX = -20; }, // down - rotate down
	    38: function(viewer){ viewer.camRotStepX =  20; }, // up - rotate up
	    37: function(viewer){ viewer.camRotStepY =  20; }, // left - rotate left
	    39: function(viewer){ viewer.camRotStepY = -20; }  // right - rotate right
    };

    this.registerLayer('main_mesh', 'Main mesh');
    this.registerLayer('solid_objects', 'Solid Objects');
    this.registerLayer('items', 'Items');
    this.registerLayer('collision', 'Collision');

    this.hud.addMonitor("X", () => this.camera.position.x.toFixed(2));
    this.hud.addMonitor("Y", () => this.camera.position.y.toFixed(2));
    this.hud.addMonitor("Z", () => this.camera.position.z.toFixed(2));
    this.hud.addMonitor("Camera speed", () => this.cameraSpeed);

    this.hud.addCheckbox("Enable fog", (checked) => {
        this.scene.fog.near = checked ? 1 : 65535;
        this.scene.fog.far = checked ? 2000 : 65535;
    });

    this.hud.addCheckbox("Low resolution", (checked) => {
        this.renderer.setPixelRatio(window.devicePixelRatio * (checked ? 0.5 : 1));
    });

    this.hud.addCheckbox("Show main mesh", (checked) => {
        this.layers['main_mesh'].setVisible(checked);
    }, true);

    this.hud.addCheckbox("Show objects", (checked) => {
        this.layers['solid_objects'].setVisible(checked);
    }, true);

    this.hud.addCheckbox("Show items", (checked) => {
        this.layers['items'].setVisible(checked);
    }, true);

    this.hud.addCheckbox("Show collision", (checked) => {
        this.layers['collision'].setVisible(checked);
    });

    this.hud.addCheckbox("Wireframe", (checked) => {
        viewer.layers['main_mesh'].objects[0].material.forEach(mat => {
            mat.wireframe = checked;
        });
    });
}

Viewer.prototype.registerLayer = function(name, label)
{
    this.layers[name] = new ViewerLayer(this, name, label);
}

Viewer.prototype.animate = function()
{
    this.camera.translateZ(this.camStepZ);
    this.camera.translateX(this.camStepX);
    this.camera.translateY(this.camStepY);

    this.camera.rotateX(this.camRotStepX / 1000);
    this.camera.rotateY(this.camRotStepY / 1000);
    this.camera.rotation.z = 0;

    this.camStepX *= 0.5;
    this.camStepY *= 0.5;
    this.camStepZ *= 0.5;

    for(var k in this.keysDown)
    {
        if(k in this.keyEvents) this.keyEvents[k](this);
    }

    this.renderer.render(this.scene, this.camera);
    this.framesDrawn++;

    this.hud.update();

    requestAnimationFrame(this.animate.bind(this));
}

function createInstancedMeshFromObjectModel(objectModel, count)
{
    var geometry = new THREE.BufferGeometry();
    var groups = [];

    var positions = [];
    var colors = [];
    var uvs = [];
    var indices = [];
    var materials = [];

    for(var texIndex in objectModel.textures)
    {
        var textureFile = objectModel.textures[texIndex];
        
        var dataTexture = new THREE.DataTexture(textureFile.data, textureFile.width, textureFile.height, THREE.RGBAFormat);
        dataTexture.wrapS = THREE.RepeatWrapping;
        dataTexture.wrapT = THREE.RepeatWrapping;
        dataTexture.magFilter = THREE.LinearFilter;
        
        var material = new THREE.MeshBasicMaterial({
            side: THREE.BackSide,
            polygonOffset: true,
            polygonOffsetFactor: 1,
            polygonOffsetUnits: 1,
            map: dataTexture,
            transparent: !!(textureFile.flags & 0x4000)
        });

        if(material.transparent)
        {
            material.alphaTest = 0.3;
        }
        
        materials.push(material);
    }

    objectModel.traverseNodes(node => {
        if(node.node.signature != 0x10)
        {
            return;
        }

        var texIndex = node.texIndex;
        var textureFile = objectModel.textures[texIndex];
        var texWidth = textureFile ? textureFile.width : 1;
        var texHeight = textureFile ? textureFile.height : 1;

        if(typeof groups[texIndex] == 'undefined')
        {
            groups[texIndex] = {
                positions: [],
                uvs: [],
                colors: [],
                indices: []
            };
        }

        var group = groups[texIndex];

        node.geometryPackets.forEach(packet => {
            var groupIndexBase = group.positions.length / 3;

            packet.vertices.forEach(vertex => {
                group.positions.push(-(vertex.x), (vertex.z), (vertex.y));
                // todo normals
                group.uvs.push((vertex.s / 32) / texWidth / 2, (vertex.t / 32) / texHeight / 2);
            });

            packet.triangles.forEach(triangle => {
                group.indices.push(groupIndexBase + triangle.v0, groupIndexBase + triangle.v1, groupIndexBase + triangle.v2);
            });
        });
    });

    for(var texIndex in groups)
    {
        var group = groups[texIndex];
        var start = indices.length;
        var numTriangles = group.indices.length;
        var indexBase = positions.length / 3;
        for(var i in group.positions) positions.push(group.positions[i]);
        for(var i in group.colors) colors.push(group.colors[i]);
        for(var i in group.uvs) uvs.push(group.uvs[i]);
        for(var i in group.indices) indices.push(indexBase + group.indices[i]);
        geometry.addGroup(start, numTriangles, texIndex);
    }
    
    var fPositions = new Float32Array(positions);
    var fUVs = new Float32Array(uvs);
    geometry.setAttribute('position', new THREE.BufferAttribute(fPositions, 3));
    geometry.setAttribute('uv', new THREE.BufferAttribute(fUVs, 2));
    geometry.setIndex(indices);
    var mesh = new THREE.InstancedMesh(geometry, materials, count);
    return mesh;
}

Viewer.prototype.addObjects = function()
{
    // group placements by model id
    var instances = {};

    for(var nObjectPlacement in this.rr64.objectPlacements)
    {
        var objectPlacement = this.rr64.objectPlacements[nObjectPlacement];
        var objectDefinition = this.rr64.objectDefinitions[objectPlacement.objectIndex];

        var modelIndex = this.rr64.getModelIndex(objectDefinition.modelId_hi, objectDefinition.modelId_lo);

        if(!instances[modelIndex])
        {
            instances[modelIndex] = [];
        }

        instances[modelIndex].push(objectPlacement);
    }

    for(var modelIndex in instances)
    {
        var objectPlacements = instances[modelIndex];
        var objectModel = this.rr64.objectModels[modelIndex];

        var instancedMesh = createInstancedMeshFromObjectModel(objectModel, objectPlacements.length);
        
        for(var nObjectPlacement in objectPlacements)
        {
            var p = objectPlacements[nObjectPlacement];
            var position = new THREE.Vector3(-p.posX * 4, p.posZ * 4, p.posY * 4);
            var quaternion = new THREE.Quaternion(p.qX, p.qZ, p.qY, p.qW);
            var scale = new THREE.Vector3(0.5, 0.5, 0.5);
            var matrix = new THREE.Matrix4();
            matrix.compose(position, quaternion, scale);

            instancedMesh.setMatrixAt(nObjectPlacement, matrix);
        }

        this.layers['solid_objects'].add(instancedMesh);
    }
}

Viewer.prototype.addMap = function()
{
    var mapMaterials = [];
    var mapGroups = {};
    var mapPositions = [];
    var mapColors = [];
    var mapUVs = [];
    var mapIndices = [];

    var mapGeometry = new THREE.BufferGeometry();

    var defaultMaterial = new THREE.MeshBasicMaterial({
        color: 0xFF0000,
        side: THREE.DoubleSide,
    });

    // build map material array
    for(var nMapTexture in this.rr64.mapTextures)
    {
        if(typeof this.rr64.mapTextures[nMapTexture] == 'undefined')
        {
            mapMaterials.push(defaultMaterial);
            continue;
        }

        var textureFile = this.rr64.mapTextures[nMapTexture];

        var dataTexture = new THREE.DataTexture(
            textureFile.data,
            textureFile.width,
            textureFile.height,
            THREE.RGBAFormat);

        dataTexture.wrapS = THREE.RepeatWrapping;
        dataTexture.wrapT = THREE.RepeatWrapping;
        dataTexture.magFilter = THREE.LinearFilter;

        var material = new THREE.MeshBasicMaterial({
            vertexColors: THREE.VertexColors,
            side: THREE.BackSide,
            polygonOffset: true,
            polygonOffsetFactor: 1,
            polygonOffsetUnits: 1,
            map: dataTexture,
            transparent: !!(textureFile.flags & 0x4000),
            alphaTest: 0.3
        });

        mapMaterials.push(material);
    }

    // build map mesh, sort submeshes with similar materials into groups
    for(var nMapPartition in this.rr64.mapPartitions)
    {
        var mapPartition = this.rr64.mapPartitions[nMapPartition];

        var worldX = mapPartition.header.worldX;
        var worldY = mapPartition.header.worldY;
        var worldZ = mapPartition.header.worldZ;

        for(var nSubMesh in mapPartition.subMeshes)
        {
            var subMesh = mapPartition.subMeshes[nSubMesh];
            var textureFile = this.rr64.mapTextures[subMesh.header.textureFileIndex];

            if(!textureFile)
            {
                console.log("texture undefined; nMapPartition:", nMapPartition, "nSubMesh:", nSubMesh);
            }

            var texWidth = textureFile ? textureFile.width : 1;
            var texHeight = textureFile ? textureFile.height : 1;

            if(typeof mapGroups[subMesh.header.textureFileIndex] == 'undefined')
            {
                mapGroups[subMesh.header.textureFileIndex] = {
                    positions: [],
                    uvs: [],
                    colors: [],
                    indices: []
                };
            }

            var group = mapGroups[subMesh.header.textureFileIndex];

            subMesh.geometryPackets.forEach(packet => {
                var groupIndexBase = group.positions.length / 3;

                packet.vertices.forEach(vertex => {
                    group.positions.push(-(vertex.x + worldX), (vertex.z + worldZ) / 2, (vertex.y + worldY));
                    group.colors.push(vertex.r / 0xFF, vertex.g / 0xFF, vertex.b / 0xFF);
                    group.uvs.push((vertex.s / 32) / texWidth / 2, (vertex.t / 32) / texHeight / 2);
                });

                packet.triangles.forEach(triangle => {
                    group.indices.push(groupIndexBase + triangle.v0, groupIndexBase + triangle.v1, groupIndexBase + triangle.v2);
                });
            });
        }
    }

    // flatten groups
    for(var materialIndex in mapGroups)
    {
        var group = mapGroups[materialIndex];
        var start = mapIndices.length;
        var count = group.indices.length;

        var indexBase = mapPositions.length / 3;

        group.positions.forEach(n => mapPositions.push(n));
        group.colors.forEach(n => mapColors.push(n));
        group.uvs.forEach(n => mapUVs.push(n));
        group.indices.forEach(n => mapIndices.push(indexBase + n));

        mapGeometry.addGroup(start, count, materialIndex);
    }

    var fMapPositions = new Float32Array(mapPositions);
    var fMapColors = new Float32Array(mapColors);
    var fMapUVs = new Float32Array(mapUVs);
    
    mapGeometry.setAttribute('position', new THREE.BufferAttribute(fMapPositions, 3));
    mapGeometry.setAttribute('color', new THREE.BufferAttribute(fMapColors, 3));
    mapGeometry.setAttribute('uv', new THREE.BufferAttribute(fMapUVs, 2));
    mapGeometry.setIndex(mapIndices);

    var mesh = new THREE.Mesh(mapGeometry, mapMaterials)
    //this.sceneAdd('main_mesh', [ mesh ]);
    this.layers['main_mesh'].add(mesh);
}

Viewer.prototype.addItems = function()
{
    var materials = [];
    var sprites = [];

    this.rr64.itemTextures.forEach(data => {
        var dataTexture = new THREE.DataTexture(data, 64, 64, THREE.RGBAFormat);
        var material = new THREE.SpriteMaterial({ map: dataTexture, color: 0xFF0000 });
        materials.push(material);
    });

    this.rr64.itemPlacements.forEach(item => {
        var sprite = new THREE.Sprite(materials[ITEM_TEX_INDICES[item.itemId]]);
        sprite.position.set(-item.x * 4, item.z * 4, item.y * 4);
        sprite.scale.set(15, 15, 15);
        sprites.push(sprite);
    });

    //this.sceneAdd('items', sprites);
    this.layers['items'].add(sprites);
}

Viewer.prototype.loadRom = function(abRom)
{
    this.rr64 = new RoadRash64(new DataView(abRom));

    this.addMap();
    this.addItems();
    this.addObjects();

    this.layers['collision'].setVisible(false);
}

//////////////////////////////////////////////////

function ViewerLayer(viewer, name, label)
{
    this.name = name;
    this.label = label;
    this.viewer = viewer;
    this.objects = [];
}

ViewerLayer.prototype.add = function(objects)
{
    if(Array.isArray(objects))
    {
        objects.forEach(object => {
            this.objects.push(object);
            this.viewer.scene.add(object)
        });
    }
    else
    {
        this.objects.push(objects);
        this.viewer.scene.add(objects);
    }
}

ViewerLayer.prototype.setVisible = function(bVisible)
{
    this.objects.forEach(object => {
        object.visible = bVisible;
    });
}

//////////////////////////////////////////////////

function ViewerHUD()
{
    this.domElement = document.createElement('div');
    this.domElement.style = "position: absolute; margin: 10px; padding: 10px; font-size: 11px; background-color: rgba(0, 0, 0, 0.2); font-family: consolas, monospace;";
    this.variables = [];
}

ViewerHUD.prototype.addMonitor = function(label, getter)
{
    var domRow = document.createElement('div');
    var domLabel = document.createElement('span');
    var domValue = document.createElement('span');
    domLabel.innerHTML = label;
    domRow.appendChild(domLabel);
    domRow.appendChild(new Text(': '));
    domRow.appendChild(domValue);
    this.domElement.appendChild(domRow);
    this.variables.push({ domValue: domValue, getter: getter });
}

ViewerHUD.prototype.addCheckbox = function(label, onchange, defaultValue)
{
    var domRow = document.createElement('div');
    var domLabel = document.createElement('label');
    var domCheckbox = document.createElement('input');
    domLabel.style = "font-family: inherit;"
    domCheckbox.style = "margin: 0px 2px 0px 0px; vertical-align: bottom;";
    domCheckbox.setAttribute('type', 'checkbox');
    domLabel.appendChild(domCheckbox);
    domLabel.appendChild(new Text(label));
    domRow.appendChild(domLabel);
    
    domCheckbox.checked = defaultValue;

    domCheckbox.addEventListener('change', function(e)
    {
        onchange(e.target.checked);
    });

    this.domElement.appendChild(domRow);
}

ViewerHUD.prototype.update = function()
{
    for(var i in this.variables)
    {
        this.variables[i].domValue.innerHTML = this.variables[i].getter();
    }
}

//////////////////////////////////////////////////

function onromloaded(ab)
{
    document.querySelector('#info').style.display = "none";
    viewer = new Viewer('#container');
    viewer.animate();
    viewer.loadRom(ab);
}

function onromloading()
{
    document.querySelector('#info-text').innerHTML = "Loading...";
}

attachFileReader('#file', onromloaded, onromloading)
attachDropZone('body', onromloaded, onromloading);

</script>
</body>
</html>